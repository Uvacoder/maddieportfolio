/*
 * grunt-postcss-import
 * https://github.com/madzhup/grunt-postcss-import
 *
 * Copyright (c) 2014 madzhup
 * Licensed under the MIT license.
 */

'use strict';
var fs = require( 'fs');
var path = require("path");
var $ = require('jquery-deferred');
var _ = require('lodash');
var chalk = require('chalk');


module.exports = function (grunt) {

  // Please see the Grunt documentation for more information regarding task
  // creation: http://gruntjs.com/creating-tasks

  grunt.registerMultiTask('postcss_import', 'Inlining @import rules based on postcss-import', function () {

    // Iterate over all specified file groups.
    this.files.forEach(function (file) {
      
      if (!file.src.length) {
        return grunt.fail.warn('No source files were found.');
      }
      
      file.src.forEach(function(filepath){
        var dest = file.dest;
        var input = grunt.file.read(filepath);
        
        resolveImports(input, path.dirname(filepath)).done(function(less){
          grunt.file.write(dest, less);
          grunt.log.writeln('File ' + chalk.cyan(dest) + ' created.');
        });
        
      });
    });
  });
  
  function resolveImports(source, path) {
  
    var deferred = $.Deferred(), imports = {}, /*host = extractUrlParts(window.location.href).host,*/ importRegex = /@import\s+url\s*\(['"]?(.+?)['"]?\)\s*;/g, urlRegex = /url\s*\(['"]?(.+?)['"]?\)/g;

    function queuedWhen(queue) {

      var deferreds = [], prev = null;

      _.each(queue, function(fn, i) {
        deferreds.push(prev = prev ? prev.then(fn) : fn.call());
      });

      return $.when.apply($, deferreds);
    }

    function rewrite(source, baseUrl) {

      source = source.replace(/@import\s['"]?(.+?)['"]?\s*;/g, function(match, url) {
        return match.indexOf("url(")!=-1 ? match:'@import url("'+url+'");';
      });

      //return source;
      return source.replace(urlRegex, function(match, url) {
        var lessExt = '.less';
        // if url ends with '.less' then fix less path
        if (url.indexOf(lessExt, url.length - lessExt.length) !== -1) {
          return match.replace(url, extractUrlParts(url, baseUrl).url);
        }
        return match;
      });
    }

    (function resolve(source) {

      var queue = [];

      source = source.replace(/@import\s['"]?(.+?)['"]?\s*;/g, function(match, url) {
        return match.indexOf("url(")!=-1 ? match:'@import url("'+url+'");';
      });

      source.replace(importRegex, function(match, url) {

        if (!imports[url]/* && host == extractUrlParts(url).host*/) {
          queue.push(
            function() {

              try{
                var data = fs.readFileSync(url);
                //imports[url] = data.toString().replace(/\/\*(?:[^*]|\*+[^\/*])*\*+\/|^((?!:).)?\/\/.*/g, '');
                imports[url] = rewrite(data.toString().replace(/\/\*(?:[^*]|\*+[^\/*])*\*+\/|^((?!:).)?\/\/.*/g, ''), url);
              } catch (err) {
                imports[url] = "/* Can't resolve import '" + url + "' (" + err + ") */";
              }
            }
          );
        }

        return match;
      });

      queuedWhen(queue).always(function() {

        source = source.replace(importRegex, function(match, url) {
          return imports[url] ? imports[url] : match;
        });

        if (queue.length) {
          source = resolve(source);
        } else {
          deferred.resolve(source);
        }
        
      });

      return source;

    })(rewrite(source.replace(/\/\*(?:[^*]|\*+[^\/*])*\*+\/|^((?!:).)?\/\/.*/g, ''), path + '/'));

    return deferred.promise();
  }
  
  function extractUrlParts(url, baseUrl) {
  
    var urlPartsRegex = /^((?:[a-z-]+:)?\/\/(?:[^\/\?#]*\/)|([\/\\]))?((?:[^\/\\\?#]*[\/\\])*)([^\/\\\?#]*)([#\?].*)?$/,
      urlParts = url.match(urlPartsRegex), baseUrlParts,
      parts = {}, dirs = [], i;

    if (!urlParts) {
      throw new Exception("Could not parse url - '" + url + "'");
    }

    if (!urlParts[1] || urlParts[2]) {

      baseUrlParts = baseUrl.match(urlPartsRegex);

      if (!baseUrlParts) {
          throw new Exception("Could not parse url - '" + baseUrl + "'");
      }

      urlParts[1] = baseUrlParts[1];

      if (!urlParts[2]) {
          urlParts[3] = path.join(baseUrlParts[3]||'', urlParts[3] || '');
      }
    }

    if (urlParts[3]) {

      dirs = urlParts[3].replace("\\", "/").split("/");

      for (i = 0; i < dirs.length; i++) {
        if (dirs[i] === ".." && i > 0) {
          dirs.splice(i-1, 2);
          i -= 2;
        }
      }
    }

    parts.host = urlParts[1];
    parts.path = path.join(urlParts[1] || '', dirs.join("/"));
    parts.file = urlParts[4] || '';
    parts.query = urlParts[5] || '';
    parts.url = path.join(parts.path, parts.file) + parts.query;
    parts.dirs = dirs;

    return parts;
  }

};
